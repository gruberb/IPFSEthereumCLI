use std::{
	fmt::{Display, Formatter},
	path::Path,
	sync::Arc,
	time::Duration,
};

use async_trait::async_trait;
use ethers::{
	contract::{abigen, ContractFactory},
	core::types::Bytes,
	middleware::SignerMiddleware,
	providers::{Http, Provider},
	signers::{LocalWallet, Signer},
	solc::Solc,
	types::Address,
	utils::Anvil,
};

use crate::network::{Environment, NetworkError};

/// The ContractError signals anything going wrong
/// with deploying or sending the error, as well as
/// if there are network connection problems
#[derive(Debug)]
pub enum ContractError {
	/// The contract could not been deployed
	Deploying,
	/// The contract could not been sent to the network
	Sending,
	/// Cannot connect to the network/testnet
	Connecting,
}

impl From<NetworkError> for ContractError {
	fn from(_: NetworkError) -> Self {
		Self::Connecting
	}
}

impl Display for ContractError {
	fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
		match self {
			ContractError::Deploying => write!(f, "Could not deploy Contract"),
			ContractError::Sending => write!(f, "Could not send contract to network"),
			ContractError::Connecting => write!(f, "A network error occurred"),
		}
	}
}

// Implementing std Error to return a Contract error inside main.rs
impl std::error::Error for ContractError {}

/// A trait definition for being able to deploy (and load) a contract
#[async_trait(?Send)]
pub trait ContractBuilder<T> {
	async fn deploy(
		environment: Environment,
		contract_name: String,
		contract_path: String,
		value: T,
	) -> Result<Contract, ContractError>
	where
		T: Display + 'async_trait;
	// async fn load(provider: ContractProvider, address: SmartContractAddress) -> SmartContract;
}

/// After compiling the contract from the .sol file
pub struct CompiledContract {
	/// The Contract specification from ethers
	contract: ethers::abi::Contract,
	/// The generated bytes from the .sol file
	bytes: Bytes,
}

/// A contract which is succesfully sent to a mainnet or testnet
pub struct Contract {
	/// The eth address of the contract
	pub address: Address,
	/// Value of the contract
	pub value: String,
}

impl Contract {
	fn compile(contract_name: String, contract_path: String) -> CompiledContract {
		let source = Path::new(&contract_path);
		let compiled = Solc::default()
			.compile_source(source)
			.expect("Could not compile contracts");

		let (contract, bytes, _) = compiled
			.find(&contract_name)
			.expect("could not find contract")
			.into_parts_or_default();

		CompiledContract { contract, bytes }
	}
}

#[async_trait(?Send)]
impl<T: Display> ContractBuilder<T> for Contract {
	async fn deploy(
		_environment: Environment,
		contract_name: String,
		contract_path: String,
		value: T,
	) -> Result<Contract, ContractError>
	where
		T: 'async_trait,
	{
		// todo()! Somehow manage to run `Anvil` and share it between threads...
		// let client = Network::connect(environment)?;

		// This is network code which should not be here, but because of time constraints I didn't
		// manage to spawn Anvil and share it between threads.
		//---------------------------------------------------------------------------------------//
		let anvil = Anvil::new().spawn();
		let wallet: LocalWallet = anvil.keys()[0].clone().into();
		let provider = Provider::<Http>::try_from(anvil.endpoint())
			.map_err(|_| NetworkError::NoConnection)?
			.interval(Duration::from_millis(10u64));
		let client = SignerMiddleware::new(provider, wallet.with_chain_id(anvil.chain_id()));
		let client = Arc::new(client);
		//---------------------------------------------------------------------------------------//

		let compiled_contract = Contract::compile(contract_name, contract_path);
		let factory = ContractFactory::new(
			compiled_contract.contract,
			compiled_contract.bytes,
			client.clone(),
		);

		let ether_contract = factory
			.deploy(value.to_string())
			.map_err(|err| {
				println!("{:?}", err);
				ContractError::Deploying
			})?
			.send()
			.await
			.map_err(|err| {
				println!("{:?}", err);
				ContractError::Sending
			})?;

		// Get the validation that all went right

		// Generate the type-safe contract bindings by providing the ABI
		// definition
		abigen!(
			SimpleContract,
			"./contracts/contract_abi.json",
			event_derives(serde::Deserialize, serde::Serialize)
		);

		// Instantiate the contract
		let contract = SimpleContract::new(ether_contract.address(), client.clone());

		// Get all events
		let logs: Vec<ValueChangedFilter> = contract
			.value_changed_filter()
			.from_block(0u64)
			.query()
			.await
			.unwrap();

		// Read the new value from the logs
		let new_value = logs[0].clone().new_value;

		Ok(Contract {
			address: contract.address(),
			value: new_value,
		})
	}
}

#[cfg(test)]
mod tests {
	use super::*;

	#[test]
	fn contract_compiles() {
		let compiled_contract =
			Contract::compile("SimpleStorage".to_string(), "./contracts".to_string());
		assert_eq!(compiled_contract.contract.events.len(), 1);
	}
}
